## 二分查找（Binary Search）

1、针对有序数据集合的查找算法；
2、时间复杂度O(logn)

## 二分查找的循环实现（无重复元素）

```
const BinarySearch = ( arr, val ) => {
	let low = 0, high = arr.length - 1;

	while( low <= high ){
		let mid = parseInt( low + (high-low) / 2 );
		if( arr[mid] === val ){
			return mid;
		}else if( arr[mid] < val ){
			low = mid + 1;
		}else{
			high = mid - 1;
		}
	}
	return -1;
}

var arr1 = [4,5,6,8,9,10,30]
BinarySearch(arr1,4)
BinarySearch(arr1,8)
BinarySearch(arr1,30)
```

## 二分查找的递归实现（无重复元素）

```
const BinarySearch = ( arr, val ) => {
	return search(arr, 0, arr.length - 1, val)
}
const search = ( arr, low, high, val ) => {
	if( low > high ){
		return -1;
	}
	let mid = parseInt( low + (high-low) / 2 );
	if( arr[mid] === val ){
		return mid;
	}else if( arr[mid] < val ){
		return search( arr, mid+1, high, val)
	}else{
		return search( arr, low, mid-1, val)
	}
}
```

## 二分查找第一个等于给定值的元素（有重复元素）

```
const BinarySearch = (arr,value) => {
	let low = 0;
	let high = arr.length - 1;
 
	while(low <= high){
		let mid = parseInt(low + (high - low) / 2);
		if(arr[mid] < value){
			low = mid + 1;
		}else if(arr[mid] > value){
			high = mid - 1;
		}else{
			if(mid == 0 || arr[mid-1] != value){
				return mid
			}else{
				high = mid - 1;
			}
		}
	}

	return -1;
}

var arr1 = [4,5,7,8,8,8,9,10,30]
var arr2 = [8,8,8,9,10,30]
BinarySearch(arr1,8)
BinarySearch(arr2,8)
```

## 二分查找最后一个等于给定值的元素（有重复元素）

```
const BinarySearch = (arr,value) => {
	let low = 0;
	let high = arr.length - 1;
 
	while(low <= high){
		let mid = parseInt(low + (high - low) / 2);
		if(arr[mid] < value){
			low = mid + 1;
		}else if(arr[mid] > value){
			high = mid - 1;
		}else{
			if(mid == arr.length-1 || arr[mid+1] != value){
				return mid
			}else{
				low = mid + 1;
			}
		}
	}

	return -1;
}

var arr1 = [4,5,7,8,8,8,9,10,30]
var arr2 = [4,5,7,8,8,8]
BinarySearch(arr1,8)
BinarySearch(arr2,8)
```

## 二分查找第一个大于等于给定值的元素（有重复元素）

```
const BinarySearch = (arr,value) => {
	let low = 0;
	let high = arr.length - 1;
 
	while(low <= high){
		let mid = parseInt(low + (high - low) / 2);
		if(arr[mid] >= value){
			if(mid == 0 || arr[mid-1] < value){
				return mid;
			}else{
				high = mid -1;
			}
		}else{
			low = mid + 1;
		}
	}

	return -1;
}

var arr1 = [4,5,6,8,9,10,30]
BinarySearch(arr1,6)

```

## 二分查找最后一个小于等于给定值的元素（有重复元素）

```
const BinarySearch = (arr,value) => {
	let low = 0;
	let high = arr.length - 1;
 
	while(low <= high){
		let mid = parseInt(low + (high - low) / 2);
		if(arr[mid] > value){
			high = mid -1;
		}else{
			if(mid == arr.length - 1 || arr[mid+1] > value){
				return mid;
			}else{
				low = mid + 1;
			}
		}
	}

	return -1;
}

var arr1 = [4,5,6,8,9,10,30]
BinarySearch(arr1,6)
```
